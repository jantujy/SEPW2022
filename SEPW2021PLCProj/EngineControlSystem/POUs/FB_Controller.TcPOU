<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="FB_Controller" Id="{e1a61c1e-d3a9-4921-8bcd-55ef990d7c3c}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_Controller
VAR_INPUT
	ssMethodType: SINT;
	speedrefrpm: LREAL;
	Current_abc: ARRAY[0..2] OF LREAL;
	speedmeasrad: LREAL;
	anglerad: LREAL;
END_VAR
VAR_OUTPUT
	Voltageoutalphabeta: ARRAY[0..1] OF LREAL;
	Electrictorguecommand: LREAL;
	Currentmeasalphabeta: ARRAY[0..1] OF LREAL;
	Currentmeasdq: ARRAY[0..1] OF LREAL;
	Currentcommanddq: ARRAY[0..1] OF LREAL;
	Voltagecommanddq: ARRAY[0..1] OF LREAL;
	Voltagecommandalphabeta: ARRAY[0..1] OF LREAL;
END_VAR
VAR
	rtb_IntegralGain: LREAL;
	rtb_DeadZone: LREAL;
	rtb_DeadZone_p: LREAL;
	rtb_idref: LREAL;
	rtb_Gain3: LREAL;
	rtb_IntegralGain_p: LREAL;
	rtb_Gain4: LREAL;
	rtb_Fcn: LREAL;
	rtb_Integrator_k: LREAL;
	rtb_Fcn1: LREAL;
	rtb_iqref: LREAL;
	rtb_IntegralGain_h: LREAL;
	rtb_DeadZone_c: LREAL;
	rtb_Saturation: LREAL;
	rtb_Switch2: SINT;
	rtb_Switch1: SINT;
	rtb_Saturation_h_idx_0: LREAL;
	rtb_Saturation_h_idx_1: LREAL;
	temp1: LREAL;
	Gain3: LREAL;
	Integrator_DSTATE: LREAL;
	Integrator_DSTATE_c: LREAL;
	Integrator_DSTATE_m: LREAL;
	Gain2: LREAL;
	Sqrt2: LREAL;
	Gain4: LREAL;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[

CASE ssMethodType OF
    SS_INITIALIZE: 
        (* SystemInitialize for Atomic SubSystem: '<Root>/Controller_subsystem_29112022' *)
        (* InitializeConditions for DiscreteIntegrator: '<S145>/Integrator' *)
        Integrator_DSTATE := 0.0;
        (* InitializeConditions for DiscreteIntegrator: '<S43>/Integrator' *)
        Integrator_DSTATE_c := 0.0;
        (* InitializeConditions for DiscreteIntegrator: '<S93>/Integrator' *)
        Integrator_DSTATE_m := 0.0;
        (* End of SystemInitialize for SubSystem: '<Root>/Controller_subsystem_29112022' *)
        

        (* ConstCode for Atomic SubSystem: '<Root>/Controller_subsystem_29112022' *)
        (* ConstCode for Gain: '<S3>/Gain2' incorporates:
         *  Constant: '<S3>/Constant' *)
        Gain2 := 2.1427199999999997;
        (* ConstCode for Sqrt: '<S3>/Sqrt2' incorporates:
         *  Constant: '<S3>/Constant1' *)
        Sqrt2 := 1.4142135623730951;
        (* ConstCode for Gain: '<S3>/Gain3' *)
        Gain3 := 0.44739 * Sqrt2;
        (* ConstCode for Gain: '<S3>/Gain4' incorporates:
         *  Constant: '<S3>/Constant2' *)
        Gain4 := 2.1427199999999997;
        (* End of ConstCode for SubSystem: '<Root>/Controller_subsystem_29112022' *)
    SS_STEP: 
        (* Outputs for Atomic SubSystem: '<Root>/Controller_subsystem_29112022' *)
        (* Sum: '<S4>/Add1' incorporates:
         *  Gain: '<S1>/toRad' *)
        rtb_IntegralGain := (0.10471975511965977 * speedrefrpm) - speedmeasrad;
        (* Sum: '<S154>/Sum' incorporates:
         *  DiscreteIntegrator: '<S145>/Integrator'
         *  Gain: '<S150>/Proportional Gain' *)
        rtb_DeadZone := (0.1 * rtb_IntegralGain) + Integrator_DSTATE;
        (* Saturate: '<S152>/Saturation' *)

        IF rtb_DeadZone > 7.0 THEN 
            rtb_DeadZone_p := 7.0;
        ELSIF rtb_DeadZone >= -7.0 THEN 
            rtb_DeadZone_p := rtb_DeadZone;
        ELSE 
            rtb_DeadZone_p := -7.0;
        END_IF;

        (* End of Saturate: '<S152>/Saturation' *)
        

        (* Switch: '<S4>/Switch' incorporates:
         *  Constant: '<S4>/Constant3' *)

        IF rtb_DeadZone_p <> 0.0 THEN 
            Electrictorguecommand := rtb_DeadZone_p;
        ELSE 
            Electrictorguecommand := 0.01;
        END_IF;

        (* End of Switch: '<S4>/Switch' *)
        

        (* Product: '<S3>/Divide1' incorporates:
         *  Abs: '<S3>/Abs'
         *  Gain: '<S3>/Gain1'
         *  Product: '<S3>/Divide'
         *  Sqrt: '<S3>/Sqrt1' *)
        temp1 := ABS(Electrictorguecommand);
        rtb_idref := SQRT((0.1615435812 * temp1) / Gain2) / Gain3;
        (* Gain: '<S5>/Gain3' incorporates:
         *  Gain: '<S5>/Gain1'
         *  Gain: '<S5>/Gain2'
         *  Sum: '<S5>/Sum' *)
        rtb_Gain3 := (((-0.5 * Current_abc[1]) + Current_abc[0]) + (-0.5 * Current_abc[2])) * 0.66666666666666663;
        (* Gain: '<S5>/Gain4' incorporates:
         *  Gain: '<S5>/Gain6'
         *  Gain: '<S5>/Gain7'
         *  Sum: '<S5>/Sum1' *)
        rtb_Gain4 := ((0.8660254037844386 * Current_abc[1]) + (-0.8660254037844386 * Current_abc[2])) * 0.66666666666666663;
        (* Fcn: '<S6>/Fcn' incorporates:
         *  Fcn: '<S6>/Fcn1'
         *  Fcn: '<S7>/Fcn'
         *  Fcn: '<S7>/Fcn1' *)
        rtb_Saturation_h_idx_0 := SIN(anglerad);
        rtb_Saturation_h_idx_1 := COS(anglerad);
        rtb_Fcn := (rtb_Gain3 * rtb_Saturation_h_idx_1) + (rtb_Gain4 * rtb_Saturation_h_idx_0);
        (* Sum: '<S2>/Add' *)
        rtb_IntegralGain_p := rtb_idref - rtb_Fcn;
        (* Sum: '<S52>/Sum' incorporates:
         *  DiscreteIntegrator: '<S43>/Integrator'
         *  Gain: '<S48>/Proportional Gain' *)
        rtb_DeadZone_p := (2.0 * rtb_IntegralGain_p) + Integrator_DSTATE_c;
        (* Saturate: '<S50>/Saturation' *)

        IF rtb_DeadZone_p > 400.0 THEN 
            rtb_Integrator_k := 400.0;
        ELSIF rtb_DeadZone_p >= -400.0 THEN 
            rtb_Integrator_k := rtb_DeadZone_p;
        ELSE 
            rtb_Integrator_k := -400.0;
        END_IF;

        (* End of Saturate: '<S50>/Saturation' *)
        

        (* Fcn: '<S6>/Fcn1' *)
        rtb_Fcn1 := (( -rtb_Gain3) * rtb_Saturation_h_idx_0) + (rtb_Gain4 * rtb_Saturation_h_idx_1);
        (* Product: '<S3>/Divide2' incorporates:
         *  Gain: '<S3>/Gain5'
         *  Product: '<S3>/Multiply' *)
        rtb_iqref := (2.0 * Electrictorguecommand) / (Gain4 * rtb_idref);
        (* Sum: '<S2>/Add1' *)
        rtb_IntegralGain_h := rtb_iqref - rtb_Fcn1;
        (* Sum: '<S2>/Add2' incorporates:
         *  Gain: '<S2>/Gain'
         *  Product: '<S2>/Product' *)
        rtb_Integrator_k := rtb_Integrator_k - ((0.09027 * rtb_Fcn1) * speedmeasrad);
        (* Sum: '<S102>/Sum' incorporates:
         *  DiscreteIntegrator: '<S93>/Integrator'
         *  Gain: '<S98>/Proportional Gain' *)
        rtb_DeadZone_c := (2.0 * rtb_IntegralGain_h) + Integrator_DSTATE_m;
        (* Saturate: '<S100>/Saturation' *)

        IF rtb_DeadZone_c > 400.0 THEN 
            rtb_Saturation := 400.0;
        ELSIF rtb_DeadZone_c >= -400.0 THEN 
            rtb_Saturation := rtb_DeadZone_c;
        ELSE 
            rtb_Saturation := -400.0;
        END_IF;

        (* End of Saturate: '<S100>/Saturation' *)
        

        (* Sum: '<S2>/Add3' incorporates:
         *  Gain: '<S2>/Gain1'
         *  Product: '<S2>/Product1' *)
        rtb_Saturation := ((0.44739 * rtb_Fcn) * speedmeasrad) + rtb_Saturation;
        (* Saturate: '<S1>/Saturation' incorporates:
         *  Fcn: '<S7>/Fcn'
         *  Fcn: '<S7>/Fcn1'
         *  Outport: '<Root>/Voltage command alpha-beta' *)
        Voltagecommandalphabeta[0] := (rtb_Integrator_k * rtb_Saturation_h_idx_1) - (rtb_Saturation * rtb_Saturation_h_idx_0);
        Voltagecommandalphabeta[1] := (rtb_Integrator_k * rtb_Saturation_h_idx_0) + (rtb_Saturation * rtb_Saturation_h_idx_1);

        IF Voltagecommandalphabeta[0] > 400.0 THEN 
            rtb_Saturation_h_idx_0 := 400.0;
        ELSIF Voltagecommandalphabeta[0] >= -400.0 THEN 
            rtb_Saturation_h_idx_0 := Voltagecommandalphabeta[0];
        ELSE 
            rtb_Saturation_h_idx_0 := -400.0;
        END_IF;


        IF Voltagecommandalphabeta[1] > 400.0 THEN 
            rtb_Saturation_h_idx_1 := 400.0;
        ELSIF Voltagecommandalphabeta[1] >= -400.0 THEN 
            rtb_Saturation_h_idx_1 := Voltagecommandalphabeta[1];
        ELSE 
            rtb_Saturation_h_idx_1 := -400.0;
        END_IF;

        (* End of Saturate: '<S1>/Saturation' *)
        

        (* DeadZone: '<S36>/DeadZone' *)

        IF rtb_DeadZone_p > 400.0 THEN 
            rtb_DeadZone_p := rtb_DeadZone_p - 400.0;
            (* Switch: '<S34>/Switch1' incorporates:
             *  Constant: '<S34>/Constant' *)
            rtb_Switch2 := 1;
        ELSE 

            IF rtb_DeadZone_p >= -400.0 THEN 
                rtb_DeadZone_p := 0.0;
            ELSE 
                rtb_DeadZone_p := rtb_DeadZone_p - -400.0;
            END_IF;

            (* Switch: '<S34>/Switch1' incorporates:
             *  Constant: '<S34>/Constant2' *)
            rtb_Switch2 := -1;
        END_IF;

        (* End of DeadZone: '<S36>/DeadZone' *)
        

        (* Gain: '<S40>/Integral Gain' *)
        rtb_IntegralGain_p := 0.2 * rtb_IntegralGain_p;
        (* Switch: '<S34>/Switch2' incorporates:
         *  Constant: '<S34>/Clamping_zero'
         *  Constant: '<S34>/Constant3'
         *  Constant: '<S34>/Constant4'
         *  RelationalOperator: '<S34>/fix for DT propagation issue1' *)

        IF rtb_IntegralGain_p > 0.0 THEN 
            rtb_Switch1 := 1;
        ELSE 
            rtb_Switch1 := -1;
        END_IF;

        (* End of Switch: '<S34>/Switch2' *)
        

        (* Switch: '<S34>/Switch' incorporates:
         *  Constant: '<S34>/Clamping_zero'
         *  Constant: '<S34>/Constant1'
         *  Logic: '<S34>/AND3'
         *  RelationalOperator: '<S34>/Equal1'
         *  RelationalOperator: '<S34>/Relational Operator' *)

        IF (rtb_DeadZone_p <> 0.0) AND (rtb_Switch2 = rtb_Switch1) THEN 
            rtb_IntegralGain_p := 0.0;
        END_IF;

        (* End of Switch: '<S34>/Switch' *)
        

        (* DeadZone: '<S86>/DeadZone' *)

        IF rtb_DeadZone_c > 400.0 THEN 
            rtb_DeadZone_c := rtb_DeadZone_c - 400.0;
            (* Switch: '<S84>/Switch1' incorporates:
             *  Constant: '<S84>/Constant' *)
            rtb_Switch1 := 1;
        ELSE 

            IF rtb_DeadZone_c >= -400.0 THEN 
                rtb_DeadZone_c := 0.0;
            ELSE 
                rtb_DeadZone_c := rtb_DeadZone_c - -400.0;
            END_IF;

            (* Switch: '<S84>/Switch1' incorporates:
             *  Constant: '<S84>/Constant2' *)
            rtb_Switch1 := -1;
        END_IF;

        (* End of DeadZone: '<S86>/DeadZone' *)
        

        (* Gain: '<S90>/Integral Gain' *)
        rtb_IntegralGain_h := 0.2 * rtb_IntegralGain_h;
        (* Switch: '<S84>/Switch2' incorporates:
         *  Constant: '<S84>/Clamping_zero'
         *  Constant: '<S84>/Constant3'
         *  Constant: '<S84>/Constant4'
         *  RelationalOperator: '<S84>/fix for DT propagation issue1' *)

        IF rtb_IntegralGain_h > 0.0 THEN 
            rtb_Switch2 := 1;
        ELSE 
            rtb_Switch2 := -1;
        END_IF;

        (* End of Switch: '<S84>/Switch2' *)
        

        (* Switch: '<S84>/Switch' incorporates:
         *  Constant: '<S84>/Clamping_zero'
         *  Constant: '<S84>/Constant1'
         *  Logic: '<S84>/AND3'
         *  RelationalOperator: '<S84>/Equal1'
         *  RelationalOperator: '<S84>/Relational Operator' *)

        IF (rtb_DeadZone_c <> 0.0) AND (rtb_Switch1 = rtb_Switch2) THEN 
            rtb_IntegralGain_h := 0.0;
        END_IF;

        (* End of Switch: '<S84>/Switch' *)
        

        (* DeadZone: '<S138>/DeadZone' *)

        IF rtb_DeadZone > 7.0 THEN 
            rtb_DeadZone := rtb_DeadZone - 7.0;
            (* Switch: '<S136>/Switch1' incorporates:
             *  Constant: '<S136>/Constant' *)
            rtb_Switch1 := 1;
        ELSE 

            IF rtb_DeadZone >= -7.0 THEN 
                rtb_DeadZone := 0.0;
            ELSE 
                rtb_DeadZone := rtb_DeadZone - -7.0;
            END_IF;

            (* Switch: '<S136>/Switch1' incorporates:
             *  Constant: '<S136>/Constant2' *)
            rtb_Switch1 := -1;
        END_IF;

        (* End of DeadZone: '<S138>/DeadZone' *)
        

        (* Gain: '<S142>/Integral Gain' *)
        rtb_IntegralGain := 0.05 * rtb_IntegralGain;
        (* Switch: '<S136>/Switch2' incorporates:
         *  Constant: '<S136>/Clamping_zero'
         *  Constant: '<S136>/Constant3'
         *  Constant: '<S136>/Constant4'
         *  RelationalOperator: '<S136>/fix for DT propagation issue1' *)

        IF rtb_IntegralGain > 0.0 THEN 
            rtb_Switch2 := 1;
        ELSE 
            rtb_Switch2 := -1;
        END_IF;

        (* End of Switch: '<S136>/Switch2' *)
        

        (* Switch: '<S136>/Switch' incorporates:
         *  Constant: '<S136>/Clamping_zero'
         *  Constant: '<S136>/Constant1'
         *  Logic: '<S136>/AND3'
         *  RelationalOperator: '<S136>/Equal1'
         *  RelationalOperator: '<S136>/Relational Operator' *)

        IF (rtb_DeadZone <> 0.0) AND (rtb_Switch1 = rtb_Switch2) THEN 
            rtb_IntegralGain := 0.0;
        END_IF;

        (* End of Switch: '<S136>/Switch' *)
        

        (* Update for DiscreteIntegrator: '<S145>/Integrator' *)
        Integrator_DSTATE := (5.0E-5 * rtb_IntegralGain) + Integrator_DSTATE;
        (* Update for DiscreteIntegrator: '<S43>/Integrator' *)
        Integrator_DSTATE_c := (5.0E-5 * rtb_IntegralGain_p) + Integrator_DSTATE_c;
        (* Update for DiscreteIntegrator: '<S93>/Integrator' *)
        Integrator_DSTATE_m := (5.0E-5 * rtb_IntegralGain_h) + Integrator_DSTATE_m;
        (* Outport: '<Root>/Voltage out alpha-beta' incorporates:
         *  Gain: '<S1>/normalize' *)
        Voltageoutalphabeta[0] := 0.0025 * rtb_Saturation_h_idx_0;
        Voltageoutalphabeta[1] := 0.0025 * rtb_Saturation_h_idx_1;
        (* End of Outputs for SubSystem: '<Root>/Controller_subsystem_29112022' *)
        

        (* Outport: '<Root>/Current meas alpha-beta' *)
        Currentmeasalphabeta[0] := rtb_Gain3;
        Currentmeasalphabeta[1] := rtb_Gain4;
        (* Outport: '<Root>/Current meas dq' *)
        Currentmeasdq[0] := rtb_Fcn;
        Currentmeasdq[1] := rtb_Fcn1;
        (* Outport: '<Root>/Current command dq' *)
        Currentcommanddq[0] := rtb_idref;
        Currentcommanddq[1] := rtb_iqref;
        (* Outport: '<Root>/Voltage command dq' *)
        Voltagecommanddq[0] := rtb_Integrator_k;
        Voltagecommanddq[1] := rtb_Saturation;
END_CASE;


]]></ST>
    </Implementation>
    <LineIds Name="FB_Controller">
      <LineId Id="3" Count="353" />
      <LineId Id="2" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>